# 目标效果

内存页表可以正常修改，并对对应的虚拟地址进行访问。
并且 `page_check` 成功。


# 数据 Cache

## 写穿透

若数据 Cache 不设定为写穿透 (Write-Through) 模式的话，在读取数据时意外卡住。
可能是因为页表被修改后仍然在 Cache 中，但物理内存没有被修改，
CPU 的 TTB0 也仅仅记录的是物理地址，最终 CPU 的 MMU 在查页表过程中并没有找到页。

同理也会有其他的问题可能会出现。
为了避免过高的实现代价，若需要启用数据 Cache，建议第一级和第二级页表内均设定为写穿透 (Write-Through)。

## 一致性

若两个虚拟地址，比如内核虚拟地址和用户空间分给的地址，
在页表中也没有被设定为可分享 (Shareable) 的段或页，多核的情况下分别进行修改时，有可能会产生缓存不一致的情况。
因此为了保证开启 Cache 的时候能保持一致性，建议第一级和第二级页表内均设定为可分享 (Shareable)。
