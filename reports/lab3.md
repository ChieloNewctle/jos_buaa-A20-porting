# 目标效果

IRQ 中断、时钟、上下文切换等工作正常。
两个进程其中一个会输出一下 `cpsr` 的值，
然后一个不断输出大写字母，另一个不断输出小写字母，字母的 ASCII 连续增长。


# GIC

我所使用的 A20 的中断控制器是 GIC，
阅读 ARM 的文档和 Allwinner 的 Linux (sunxi) 内核了解了大致的使用方式。

具体实现写在了 drivers/gic 中。

感觉若系统规模变大的话，GIC 的作用和优势会更明显。


# Timer

阅读 A20 User Manual，推荐了使用 MMIO 的 Timer2 做周期性的时钟中断。

具体实现在 drivers/timer2 中。


# 用户态信息存取

阅读文档和其它相关的资料，了解到 IRQ 中断的时候，
系统进入的是 IRQ Mode，sp（栈）, lr（返回地址） 寄存器是独立的，
分别用于独立的栈指针和异常的返回地址。

但这样对于新建进程来讲会产生麻烦。

与用户态使用完全相同的寄存器是 System mode，有着更高的权限。
所以可以临时切换到 System mode 来存取用户态的 sp 和 lr。


# 上下文切换

需要切换 TTB (c2, Translation Table Base Register)，即切换页表，该寄存器在提权模式才能访问；
需要切换 Context ID (c13, Context ID Register)，即切换 ASID。

但是是这两个步骤，文档中提示到两个操作的同步问题。

给出的例子有两种：
- 先切换 ASID 到一个固定、保留的值，比如 `0`，然后更换页表，再切换到目标的 ASID
- 先切换到一个仅有公共部分的页表，比如启动时用的页表，然后更换 ASID，再切换到目标的页表


# 页目录复制

由于我直接使用 ARM 定义的一级页表作页目录，
一个问题是每次需要的是连续的4个页面的大小才能构造一个页目录，并且需要 4096 项对齐。
简易、临时的解决方法是只把4096页对齐的插入页的空闲列表。


# 内核 bss 段

当用户进程等编译到内核后，`bss` 段渐渐地被挤到后方，也暴露出了 `DRAM` 初始时不为零可能产生的问题。
`gcc` 很聪明地将初始时为 `0` 的变量都放在了 `bss` 段，认为会默认将这部分清空为 `0`，`objdump` 后这些部分也并不在二进制文件中。
但 u-boot 没有清零 `bss` 段，所以很多变量被发现并不为设定的初始值 `0`，导致出现大量问题。

解决方法是在 `CFLAGS` 中加入 `-fno-zero-initialized-in-bss`。

